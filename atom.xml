<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[一泓清泉的Blog]]></title>
  <link href="http://ishun.github.io/MyBlog/atom.xml" rel="self"/>
  <link href="http://ishun.github.io/MyBlog/"/>
  <updated>2016-12-01T15:42:03+08:00</updated>
  <id>http://ishun.github.io/MyBlog/</id>
  <author>
    <name><![CDATA[一泓清泉]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS APP逆向实践]]></title>
    <link href="http://ishun.github.io/MyBlog/blog/2016/12/01/Post-iOS%20APP%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/"/>
    <updated>2016-12-01T23:00:00+08:00</updated>
    <id>http://ishun.github.io/MyBlog/blog/2016/12/01/Post-iOS APP逆向实践</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>当你看到一款惊艳的APP，想知道他的实现方式，但是又不能直接获取代码时，工程逆向往往是一个较好的方式。一般而言，了解某APP的view布局，并dump出他的所有类，那么分析猜测他的实现就有突破口了。</p>

<p>下面从两方面在说明如果查看某个app的view布局，又该如何获取他的类头文件。以下实践的基础是你得有一款越狱手机，并且安装了openSSH</p>

<h2>查看view布局</h2>

<h4>方法一</h4>

<ul>
<li><p>直接在手机上安装Revealoader，进入设置->Reveal->Enabled APP->选择你的目标APP，并开启</p></li>
<li><p>重启手机</p></li>
<li><p>手机打开目标APP，在mac上安装Reveal，打开Reveal，左上角连接目标APP，如果报 <code>The network connection was lost</code>这种错误。请确认你的手机和电脑在同一局域网下，并且没有连接代理。</p></li>
</ul>


<h4>方法二</h4>

<ul>
<li>打开mac上的Reveal，点击菜单Help / Show Reveal Library in Finder，获取libReveal.dylib</li>
<li>将libReveal.dylib上传到设备的/Library/MobileSubstrate/DynamicLibraries</li>
<li>编辑并上传一个libReveal.plist，格式和/Library/MobileSubstrate/DynamicLibraries下面的其他plist类似，其中的filter的bundle写要查看的iOS App的bundle Id。
格式如下：
{ Filter = { Bundles = ( &ldquo;你要查看的app的bundle Id&rdquo; ); }; }</li>
</ul>


<p> <code>scp -r /Users/your/Desktop/libReveal.plist root@30.10.204.49:/Library/MobileSubstrate/DynamicLibraries/
</code>
输入密码: alpine
- 你要查看的app bundle id最简单的获取方式是：解压ipa文件，从plist里面可以看到bundle id
- 重启iOS设备</p>

<h2>Dump Class文件</h2>

<h4>准备Dump工具</h4>

<ul>
<li>下载<a href="http://stevenygard.com/projects/class-dump/">class-dump</a>工具</li>
<li>打开Terminal，输入mkdir ~/bin，在当前用户根目录下创建一个bin目录</li>
<li>将刚才的Class-dump可执行文件拷贝到 ~/bin目录下</li>
<li>赋予其可执行权限 chmod +x ~/bin/class-dump</li>
<li>打开~/.bash_profile文件：<code>vi ~/.bash_profile</code>，在文件最上方加一行：<code>export PATH=$HOME/bin/:$PATH</code>，然后保存并退出</li>
<li>在Terminal中执行<code>source ~/.bash_profile</code></li>
<li>这样就把~/bin路径给加入了环境变量</li>
<li>在终端class-dump一下，试试能不能成功，成功则继续</li>
</ul>


<h4>准备目标app的ipa文件</h4>

<p>由于从AppStore下载的应用都加了壳，如果想dump必须先砸壳，具体可以用Clutch工具砸壳。为简单起见，我选择从越狱市场下载目标app，默认都是不带壳的。</p>

<ul>
<li>解压ipa文件，找到.app文件</li>
<li>在终端执行 <code>class-dump -H [你的.app文件路径] -o [你指定的dump class存放路径]</code></li>
</ul>


<p>这样在你指定的路径里就可以看到被Dump的class了</p>

<h2>参考文档</h2>

<pre><code>1、 http://www.cnblogs.com/mddblog/p/4942894.html
2、 http://bbs.iosre.com/t/10-11-usr-bin-class-dump/1936
3、 http://www.jianshu.com/p/d172826fe578
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iPhone相册视频文件读写与转存]]></title>
    <link href="http://ishun.github.io/MyBlog/blog/2016/11/09/Post-iPhone%E7%9B%B8%E5%86%8C%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E4%B8%8E%E8%BD%AC%E5%AD%98/"/>
    <updated>2016-11-09T23:21:35+08:00</updated>
    <id>http://ishun.github.io/MyBlog/blog/2016/11/09/Post-iPhone相册视频文件读写与转存</id>
    <content type="html"><![CDATA[<h2>背景介绍</h2>

<p>   最近在做一个涉及图像视频的项目，简单说就是在手机上对相册、或者本地文件中的视频文件读取、解码成图像并展示。</p>

<h2>走过的弯路</h2>

<p>一般情况下，用<code>AVAssetImageGenerator</code>对相册视频解码，只需用相册视频url生成<code>AVAsset</code>对象，然后读取视频<code>CMTime</code>即可。</p>

<p>由于项目是多人开发，视频解码是封装在底层，业务层只能输入remote url或者file url，而相册视频文件并不属于file url，所以最先想到的办法就是能不能将相册文件写到APP沙盒里，读取沙盒中视频文件，这样就满足参数输入了，搜索stackoverflow，结果以下代码就产生了。</p>

<pre><code>ALAssetRepresentation *rep = [asset defaultRepresentation];
unsigned long repSize      = (unsigned long)rep.size;

Byte *buffer      = (Byte *)malloc(repSize);
NSUInteger length = [rep getBytes:buffer fromOffset:0 length:repSize error:nil];

NSData *myData = [NSData dataWithBytesNoCopy:buffer length:length freeWhenDone:YES];
</code></pre>

<p>刚开始发现文件length为0，进一步调试发现myData为nil，这是为啥呢？<code>asset</code>对象是非空的，然而其属性size为0，猜测是不是因为类似资源应该先被打开，然后再去访问其属性，尝试了以下代码</p>

<pre><code>ALAssetsLibrary *assetLibrary=[[ALAssetsLibrary alloc] init];
[assetLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {

        NSString *docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];
        NSString *mp4FilePath = [NSString stringWithFormat:@"%@/demo.mp4", docDir];

        ALAssetRepresentation *rep = [asset defaultRepresentation];
        Byte *buffer = (Byte*)malloc((unsigned long)rep.size);
        NSUInteger buffered = [rep getBytes:buffer fromOffset:0.0 length:(NSUInteger)rep.size error:nil];

        NSData *data = [NSData dataWithBytesNoCopy:buffer length:buffered freeWhenDone:YES];
        [data writeToFile:mp4FilePath options:NSDataWritingAtomic error:nil];
        NSURL *newFilePath = [NSURL fileURLWithPath:mp4FilePath];
} failureBlock:^(NSError *error) {
}];
</code></pre>

<p>run后发现data的length非空了，在真机上运行了几次，都可以正常解码，然而遇到了另外两个问题：1、视频文件过大时，copy时间+解码时间过长  2、低端机上由于内存占用较大，极易crash</p>

<p>个人猜测上面两个问题产生的根本原因是由于引入了malloc，文件过大时，内存占用也较大，这种方式看起来也较蹩脚，不像正派武功。再次查询AVFoundation Guide后，发现有个API应该可以为我所有，达到目的。</p>

<h2>正确的姿势</h2>

<h3>读取相册视频并copy至本地目录</h3>

<p>调用AVFoundation的AVAssetExportSession可将视频导出至自定义目录</p>

<pre><code>AVAsset *asset = [[AVURLAsset alloc] initWithURL:videoPath options:nil];

NSString *docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];
NSString *mp4FilePath = [NSString stringWithFormat:@"%@/demo.mp4", docDir];
[[NSFileManager defaultManager] removeItemAtURL:[NSURL fileURLWithPath:mp4FilePath] error:nil];

NSString *presetName = AVAssetExportPreset1280x720;
self.exportSession = [[AVAssetExportSession alloc] initWithAsset:asset
                                                      presetName:presetName];
self.exportSession.outputURL = [NSURL fileURLWithPath:mp4FilePath];
self.exportSession.outputFileType = AVFileTypeMPEG4;

[self.exportSession exportAsynchronouslyWithCompletionHandler:^(void){
    switch (weakSelf.exportSession.status) {
        case AVAssetExportSessionStatusCompleted:
            // DO YOUR WORK
            break;
        case AVAssetExportSessionStatusFailed:
            break;
        case AVAssetExportSessionStatusCancelled:
            break;
        default:
            break;
    }
}];
</code></pre>

<p>这样就解决了内存问题，在低端机型下也可以顺畅运行，看来这条道算是正派武功</p>

<h3>视频文件写入相册</h3>

<p>在项目中我们也用到了将视频文件写入相册的功能，在此贴一下代码片段，以供参考</p>

<pre><code>[_library writeVideoAtPathToSavedPhotosAlbum: outputFileURL
                             completionBlock:^(NSURL *assetURL, NSError *error) {

                                }];
</code></pre>

<h2>总结</h2>

<p>虽然最终解决了功能问题和性能问题，留给我的思考很多，首先如果项目代码架构设计的够好，就无需大费周折就研究相册视频文件转存的问题。再次有些情况下黑科技是好的，可以解决问题，但是可能并非完美的解决方案，比如上文中提到的性能问题，所以说日常项目中，尽量使用官方提供的API，这样稳定性才有保障。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress和Github搭建一个自己的博客]]></title>
    <link href="http://ishun.github.io/MyBlog/blog/2016/05/07/Post-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Octopress%E5%88%9B%E5%BB%BAGithub%20Pages%E5%8D%9A%E5%AE%A2/"/>
    <updated>2016-05-07T22:55:09+08:00</updated>
    <id>http://ishun.github.io/MyBlog/blog/2016/05/07/Post-如何利用Octopress创建Github Pages博客</id>
    <content type="html"><![CDATA[<h3>简明步骤</h3>

<ul>
<li>首先你得有个Github账号</li>
<li>再次你得有ruby环境，如果你用的mac，恭喜你，mac默认安装了ruby</li>
<li>其次你得安装Octopress</li>
<li>然后你的将Octopress部署到Github Pages上</li>
<li>最后就可以发布新帖了</li>
</ul>


<h3>详细介绍</h3>

<h4>申请Github账号</h4>

<p>注册直达电梯  <a href="http://github.com">http://github.com</a></p>

<h4>安装ruby环境</h4>

<p>使用以下命令安装ruby，同时rvm也会被安装，rvm是ruby的版本管理器</p>

<pre><code>curl -L https://get.rvm.io | bash -s stable --ruby
</code></pre>

<h4>安装Octopress</h4>

<h5>克隆Octopress库到本地</h5>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
</code></pre>

<h5>安装Octopress的依赖项</h5>

<pre><code>cd octopress
gem install bundler
bundle install
</code></pre>

<p>执行gem install bundler时可能会遇到SSL_connect returned&hellip;的错误，这时尝试切换下gem源，将https切换到http
    gem source -r <a href="https://rubygems.org/">https://rubygems.org/</a>
    gem source -a <a href="http://rubygems.org/">http://rubygems.org/</a></p>

<p>执行bundle install时可能会遇到:HTTPError Could not fetch specs&hellip;Could not fetch specs from <a href="https://rubygems.org/">https://rubygems.org/</a> 的错误，尝试改下当前目录下gemfile文件中的source，将https改为http</p>

<h5>安装完octopress的依赖后，执行以下命令安装默认主题</h5>

<pre><code>rake install
</code></pre>

<h4>将Octopress部署到你的Github上</h4>

<pre><code>执行 rake setup_github_pages
</code></pre>

<p>会让输入你的github仓库地址，你可以在github复制完地址粘贴到这里，回车继续</p>

<p>执行以下命令生成页面</p>

<pre><code>rake generate
</code></pre>

<p>执行以下命令部署页面</p>

<pre><code>rake deploy
</code></pre>

<p>将以上变更提交到source分支上面</p>

<pre><code>git branch source
git checkout source
git add .
git commit -m "init"
</code></pre>

<h4>发布新帖</h4>

<pre><code>cd octopress/source/_posts/
open .
</code></pre>

<p>在_posts/目录下新建markdown文件，命名格式为 <code>yyyy-mm-dd-Post-Title.markdown</code> <strong>注意格式必须要正确</strong>，否则文章展示不出来</p>

<p>使用markdown编辑器打开，粘贴以下信息到该文件中,其中title后面是文章标题，date是文件生成日期，comments是是否开启评论功能，categories是文章属于哪个分类目录</p>

<pre><code>---  
layout: post  
title: "Post Title"  
date: yyyy-mm-dd hh:mm:ss  
comments: true  
categories: ""  
---
</code></pre>

<p>最后执行以下命令将你的文章发布到github中</p>

<pre><code>rake gen_deploy
</code></pre>

<p>然后在过几分钟访问<a href="http://">http://</a>[your_name].github.io/[your_blogRepo]/ 是不是就看到你的文章了，O(∩_∩)O哈哈~  ，如果看不到请登录你的github->你的blog repo->setting->Options->GitHub Pages->Your site is published at <a href="http://xxx.github.io/xxx">http://xxx.github.io/xxx</a> 点击之即可</p>
]]></content>
  </entry>
  
</feed>
